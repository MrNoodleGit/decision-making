import pandas as pd
import networkx as nx

def create_dict(series_1, series_2):
    '''
    series_1, series_2: Two pandas series with the same length
    Returns dictionary with series_1 elements as keys and series_2 elements as values.
    '''
    new_dict = {key: value for key, value in zip(series_1, series_2)}

    return new_dict

# column_names = ['world', 'nodeLocation', 'NID', 'PARENTID', 'pathFromParent', 'depth', 
#                 'N', 'S', 'stepsFromRoot', 'isLeaf', 'nodeValue', 'nodeEP', 
#                 'blackremains', 'cellDistances']
    
def build_graph(file_path):
    '''
    file_path: path of a csv file containing a maze generated by treeBuilder
    Returns a Networkx graph representation of the maze
    '''
    graph_data_frame = pd.read_csv(file_path, sep='\t') # Import map into pandas data frame
    graph_data_frame['PARENTID'].fillna('X', inplace=True) # Root nodes have no parent.
    graph_depth = graph_data_frame['depth'].iloc[-1]

    column_names = list(graph_data_frame.columns)

    G = nx.DiGraph(world=graph_data_frame['world'][0], depth=graph_depth) # Create networkx graph G and set graph attributes "world" to name of map
    # of graph as designated by the depth of the last node in the file
    edge_list = list(zip(graph_data_frame['PARENTID'], graph_data_frame['NID'])) # List of (parent, child) pairs
    edge_list.pop(0) # Remove edge leading to root node.
    G.add_edges_from(edge_list)

    name_dict = create_dict(graph_data_frame['NID'], graph_data_frame['NID'])
    node_location_dict = create_dict(graph_data_frame['NID'], graph_data_frame['nodeLocation'])
    depth_dict = create_dict(graph_data_frame['NID'], graph_data_frame['depth'])
    new_observations_dict = create_dict(graph_data_frame['NID'], graph_data_frame['N'])
    steps_from_root_dict = create_dict(graph_data_frame['NID'], graph_data_frame['stepsFromRoot'])
    is_leaf_dict = create_dict(graph_data_frame['NID'], graph_data_frame['isLeaf'])

#     path_value_dict = {node: value for node, value in 
#                        zip(graph_data_frame['NID'], graph_data_frame['node_value'])
#                           }

    expected_steps_dict = create_dict(graph_data_frame['NID'], graph_data_frame['nodeEP'])
    black_remains_dict = create_dict(graph_data_frame['NID'], graph_data_frame['blackremains'])
    steps_from_parent_node_dict = create_dict(graph_data_frame['NID'], graph_data_frame['S'])
    cell_distances_dict = create_dict(graph_data_frame['NID'], graph_data_frame['cellDistances'])
    
    nx.set_node_attributes(G, name_dict, 'name')
    nx.set_node_attributes(G, node_location_dict, 'node_location')
    nx.set_node_attributes(G, depth_dict, 'depth')
    nx.set_node_attributes(G, new_observations_dict, 'new_observations')
    nx.set_node_attributes(G, steps_from_root_dict, 'steps_from_root')
    nx.set_node_attributes(G, is_leaf_dict, 'is_leaf')
#     nx.set_node_attributes(G, path_value_dict, 'path_value')
    nx.set_node_attributes(G, expected_steps_dict, 'expected_steps')
    nx.set_node_attributes(G, black_remains_dict, 'black_remains')
    nx.set_node_attributes(G, steps_from_parent_node_dict, 'steps_from_parent')
    nx.set_node_attributes(G, cell_distances_dict, 'cell_distances')

    path_from_parent_dict = {edge: path for edge, path in 
                             zip(edge_list, graph_data_frame['pathFromParent'][1:])
                            }
    steps_from_parent_edge_dict = {edge: steps for edge, steps in 
                             zip(edge_list, graph_data_frame['S'][1:])
                            }

    nx.set_edge_attributes(G, path_from_parent_dict, 'path_from_parent')
    nx.set_edge_attributes(G, steps_from_parent_edge_dict, 'weight') # Assign steps from parent to node as edge weight
    
    return G

